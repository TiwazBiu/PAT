## 思路

这道题本身很简单,插入一个数字到有序数组中可以转化为查找相应的插入位置

也就是说, 要找到a[i]<num<=a[i+1],当然num也可能比a[0]小,或者比a[-1]大,这两个边界条件的插入很好实现:

* 如果比a[0]小(num<a[i]), 插入位置就在0处
* 如果不比a[-1]小(num>=a[-1]), 就不需要插入,直接返回

现在考虑插入位置在数组之间, 查找这一位置的方法则可以分为线性查找或者对半查找,线性查找容易实现,但是复杂度是O(n),而对分查找(BinarySearch)复杂度是O(log(n)),相对繁琐些,具体说下对分查找.

BinarySearch:设原数组长度为N,

开始的搜索范围是[0,N],边界检查将范围缩小到[1,N-1],设i = 1, j = N-1

然后和中间值比较, 中间值设为m = (i+j)/2 

* 两者相等,找到插入位置一定可以是m+1,直接退出循环.


* 待插入数字比中间值大时,为保证序列非递减,在待插入数字大于中间值时,就不可能把它插入原中间值位置,故设i = m+1,即检查右侧,不用管左边的了.
* 比中间值小则检查左侧,即设j = m (注意将i,j理解为可能插入的位置就好理解多了:当待插入数字比中间值小的时候,尽管不可能将其插入到m以后的位置,但是它还是有可能插入到中间值位置的)
* 终止条件是发现i=j的时候,同样变得好理解了,这时候只有一个可能的插入位置,当然就是这里了(因为我们已经检查过边界条件,确定插入位置一定是中间的某个值)



这样分析下来,实际上不需要判断边界条件,因为边界条件本身来说也包含在下边的判断中,这样一来就能对这个对分查找的实现进行进一步简化了.